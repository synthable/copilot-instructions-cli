// Generated by Claude Sonnet 4 on 2025-06-30 14:42 PDT.
// Comprehensive tests for module schema validation in copilot-instructions-builder.
// Jest globals (describe, test, expect) are provided by the test environment

import { describe, test, expect } from '@jest/globals';
import { validateModule } from '../../src/core/module-validator';
import {
  ModuleType,
  MergeStrategy,
  Category,
  type ModuleSchema,
} from '../../src/types/module';

describe('Module Schema Validation', () => {
  const validBaseModule: ModuleSchema = {
    id: 'test-base',
    name: 'Test Base Module',
    type: ModuleType.Base,
    version: '1.0.0',
    priority: 1.0,
    metadata: {
      description: 'A test base module',
      author: 'Test Author',
      category: Category.General,
      weight: 100,
    },
    instructions: [
      {
        id: 'base-instruction',
        content: 'This is a base instruction with {{VARIABLE}} substitution.',
        merge_strategy: MergeStrategy.Replace,
      },
    ],
  };

  const validDomainModule: ModuleSchema = {
    id: 'test-domain',
    name: 'Test Domain Module',
    type: ModuleType.Domain,
    version: '2.1.3',
    priority: 1.2,
    dependencies: ['test-base'],
    tags: ['frontend', 'ui'],
    metadata: {
      description: 'A test domain module',
      author: 'Test Author',
      category: Category.Frontend,
      weight: 150,
    },
    variables: {
      FRAMEWORK: 'React',
      DEBUG_MODE: true,
    },
    instructions: [
      {
        id: 'domain-instruction',
        content:
          "Domain specific instruction using {{FRAMEWORK || 'vanilla'}}.",
        merge_strategy: MergeStrategy.Append,
        conditions: {
          require_modules: ['test-base'],
          include_if: '{{DEBUG_MODE}}',
        },
      },
    ],
    hooks: {
      pre_compose: ['npm install'],
      post_compose: ['npm run build'],
    },
  };

  const validTaskModule: ModuleSchema = {
    id: 'test-task',
    name: 'Test Task Module',
    type: ModuleType.Task,
    version: '0.5.2',
    priority: 1.5,
    dependencies: ['test-domain'],
    conflicts: ['conflicting-task'],
    metadata: {
      description: 'A test task module',
      author: 'Test Author',
      category: Category.Testing,
      weight: 200,
    },
    instructions: [
      {
        id: 'task-instruction',
        content: 'Task instruction with smart merge.',
        merge_strategy: MergeStrategy.SmartMerge,
      },
    ],
  };

  describe('Valid Module Structure', () => {
    test('should validate a complete base module', () => {
      const result = validateModule(validBaseModule);
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    test('should validate a complete domain module', () => {
      const result = validateModule(validDomainModule);
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    test('should validate a complete task module', () => {
      const result = validateModule(validTaskModule);
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    test('should validate minimal required fields', () => {
      const minimal: ModuleSchema = {
        id: 'minimal',
        name: 'Minimal Module',
        type: ModuleType.Base,
        version: '1.0.0',
        priority: 1.0,
        metadata: {
          description: 'Minimal',
          author: 'Author',
          category: Category.General,
          weight: 1,
        },
        instructions: [],
      };
      const result = validateModule(minimal);
      expect(result.valid).toBe(true);
    });
  });

  describe('Invalid Structure Rejection', () => {
    test('should reject module without required fields', () => {
      const invalid = {
        name: 'Invalid Module',
        // Missing required fields
      };
      const result = validateModule(invalid);
      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    test('should reject invalid module ID format', () => {
      const invalid = {
        ...validBaseModule,
        id: 'invalid id with spaces!',
      };
      const result = validateModule(invalid);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('id'))).toBe(true);
    });

    test('should reject invalid version format', () => {
      const invalid = {
        ...validBaseModule,
        version: '1.0',
      };
      const result = validateModule(invalid);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('version'))).toBe(true);
    });

    test('should reject invalid priority values', () => {
      const invalid = {
        ...validBaseModule,
        priority: 2.0,
      };
      const result = validateModule(invalid);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('priority'))).toBe(true);
    });

    test('should reject invalid module type', () => {
      const invalid = {
        ...validBaseModule,
        type: 'invalid-type',
      };
      const result = validateModule(invalid);
      expect(result.valid).toBe(false);
    });

    test('should reject invalid merge strategy', () => {
      const invalid = {
        ...validBaseModule,
        instructions: [
          {
            id: 'test',
            content: 'test',
            merge_strategy: 'invalid-strategy',
          },
        ],
      };
      const result = validateModule(invalid);
      expect(result.valid).toBe(false);
    });

    test('should reject invalid category', () => {
      const invalid = {
        ...validBaseModule,
        metadata: {
          ...validBaseModule.metadata,
          category: 'invalid-category',
        },
      };
      const result = validateModule(invalid);
      expect(result.valid).toBe(false);
    });
  });

  describe('Priority Consistency Validation', () => {
    test('should reject base module with wrong priority', () => {
      const invalid = {
        ...validBaseModule,
        priority: 1.2,
      };
      const result = validateModule(invalid);
      expect(result.valid).toBe(false);
      expect(
        result.errors.some(
          e => e.includes('Priority') && e.includes('does not match')
        )
      ).toBe(true);
    });

    test('should reject domain module with wrong priority', () => {
      const invalid = {
        ...validDomainModule,
        priority: 1.0,
      };
      const result = validateModule(invalid);
      expect(result.valid).toBe(false);
      expect(
        result.errors.some(
          e => e.includes('Priority') && e.includes('does not match')
        )
      ).toBe(true);
    });

    test('should reject task module with wrong priority', () => {
      const invalid = {
        ...validTaskModule,
        priority: 1.2,
      };
      const result = validateModule(invalid);
      expect(result.valid).toBe(false);
      expect(
        result.errors.some(
          e => e.includes('Priority') && e.includes('does not match')
        )
      ).toBe(true);
    });
  });

  describe('Template Variable Validation', () => {
    test('should accept valid template variable syntax', () => {
      const module = {
        ...validBaseModule,
        instructions: [
          {
            id: 'test',
            content:
              "Valid: {{VAR}}, {{VAR_NAME}}, {{VAR123}}, {{VAR || 'default'}}",
            merge_strategy: MergeStrategy.Replace,
          },
        ],
      };
      const result = validateModule(module);
      expect(result.valid).toBe(true);
    });

    test('should reject invalid template variable names', () => {
      const module = {
        ...validBaseModule,
        instructions: [
          {
            id: 'test',
            content: 'Invalid: {{lowercase}}, {{mix-case}}, {{123VAR}}',
            merge_strategy: MergeStrategy.Replace,
          },
        ],
      };
      const result = validateModule(module);
      expect(result.valid).toBe(false);
      expect(
        result.errors.some(e => e.includes('Invalid template variable syntax'))
      ).toBe(true);
    });

    test('should accept template variables with default values', () => {
      const module = {
        ...validBaseModule,
        instructions: [
          {
            id: 'test',
            content:
              'With defaults: {{NAME || \'default\'}}, {{VALUE || "quoted"}}',
            merge_strategy: MergeStrategy.Replace,
          },
        ],
      };
      const result = validateModule(module);
      expect(result.valid).toBe(true);
    });
  });

  describe('Dependency and Conflict Validation', () => {
    const allModules = [validBaseModule, validDomainModule, validTaskModule];

    test('should validate known dependencies', () => {
      const result = validateModule(validDomainModule, allModules);
      expect(result.valid).toBe(true);
    });

    test('should reject unknown dependencies', () => {
      const invalid = {
        ...validBaseModule,
        dependencies: ['unknown-module'],
      };
      const result = validateModule(invalid, allModules);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Unknown dependency'))).toBe(
        true
      );
    });

    test('should reject unknown conflicts', () => {
      const invalid = {
        ...validBaseModule,
        conflicts: ['unknown-conflict'],
      };
      const result = validateModule(invalid, allModules);
      expect(result.valid).toBe(false);
      expect(result.errors.some(e => e.includes('Unknown conflict'))).toBe(
        true
      );
    });

    test('should reject self-conflict', () => {
      const invalid = {
        ...validBaseModule,
        conflicts: ['test-base'],
      };
      const result = validateModule(invalid, allModules);
      expect(result.valid).toBe(false);
      expect(
        result.errors.some(e => e.includes('cannot conflict with itself'))
      ).toBe(true);
    });

    test('should detect dependency cycles', () => {
      const cyclicModules: ModuleSchema[] = [
        {
          ...validBaseModule,
          id: 'a',
          dependencies: ['b'],
        },
        {
          ...validDomainModule,
          id: 'b',
          dependencies: ['c'],
        },
        {
          ...validTaskModule,
          id: 'c',
          dependencies: ['a'], // Creates cycle: a -> b -> c -> a
        },
      ];

      const result = validateModule(cyclicModules[0], cyclicModules);
      expect(result.valid).toBe(false);
      expect(
        result.errors.some(e => e.includes('Dependency cycle detected'))
      ).toBe(true);
    });
  });

  describe('Edge Cases', () => {
    test('should handle empty instructions array', () => {
      const module = {
        ...validBaseModule,
        instructions: [],
      };
      const result = validateModule(module);
      expect(result.valid).toBe(true);
    });

    test('should handle missing optional fields', () => {
      const module = {
        id: 'minimal',
        name: 'Minimal',
        type: ModuleType.Base,
        version: '1.0.0',
        priority: 1.0,
        metadata: {
          description: 'Test',
          author: 'Author',
          category: Category.General,
          weight: 1,
        },
        instructions: [],
      };
      const result = validateModule(module);
      expect(result.valid).toBe(true);
    });

    test('should handle complex instruction conditions', () => {
      const module = {
        ...validBaseModule,
        instructions: [
          {
            id: 'complex',
            content: 'Complex instruction',
            merge_strategy: MergeStrategy.Prepend,
            conditions: {
              include_if: '{{DEBUG}} === true',
              exclude_if: '{{PROD}}',
              require_modules: ['base-module'],
              conflict_with: ['conflicting-module'],
            },
          },
        ],
      };
      const result = validateModule(module);
      expect(result.valid).toBe(true);
    });

    test('should handle null/undefined input', () => {
      expect(validateModule(null).valid).toBe(false);
      expect(validateModule(undefined).valid).toBe(false);
    });

    test('should handle non-object input', () => {
      expect(validateModule('string').valid).toBe(false);
      expect(validateModule(123).valid).toBe(false);
      expect(validateModule([]).valid).toBe(false);
    });
  });
});
