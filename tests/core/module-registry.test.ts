// Generated by Claude Sonnet 4 on 6/30/2025, 9:15:03 PM
// Comprehensive test suite for ModuleRegistry implementation - task 1.2.3 validation

import * as fs from 'fs/promises';
import * as path from 'path';
import {
  ModuleRegistry,
  ModuleRegistryError,
  ModuleRegistrationError,
  ModuleRegistryIOError,
} from '../../src/core/module-registry';
import type { SearchCriteria } from '../../src/core/module-registry';
import { ModuleLoader } from '../../src/core/module-loader';
import { validateModule } from '../../src/core/module-validator';
import { ModuleDiscoveryError } from '../../src/core/module-loader-errors';
import { ModuleType, Category, MergeStrategy } from '../../src/types/module';
import type { ModuleSchema } from '../../src/types/module';

// Mock the dependencies
jest.mock('fs/promises');
jest.mock('../../src/core/module-loader');
jest.mock('../../src/core/module-validator');

const mockFs = fs as jest.Mocked<typeof fs>;
const MockModuleLoader = ModuleLoader as jest.MockedClass<typeof ModuleLoader>;
const mockValidateModule = validateModule as jest.MockedFunction<
  typeof validateModule
>;

describe('ModuleRegistry', () => {
  let registry: ModuleRegistry;
  let mockModuleLoader: jest.Mocked<ModuleLoader>;

  // Sample test data
  const sampleModule1: ModuleSchema = {
    id: 'test-module-1',
    name: 'Test Module 1',
    type: ModuleType.Base,
    version: '1.0.0',
    priority: 1.0,
    dependencies: [],
    conflicts: [],
    tags: ['test', 'base'],
    metadata: {
      description: 'A test module for testing',
      author: 'Test Author',
      category: Category.General,
      weight: 10,
    },
    instructions: [
      {
        id: 'test-instruction-1',
        content: 'This is a test instruction',
        merge_strategy: MergeStrategy.Replace,
      },
    ],
  };

  const sampleModule2: ModuleSchema = {
    id: 'test-module-2',
    name: 'Test Module 2',
    type: ModuleType.Domain,
    version: '2.0.0',
    priority: 1.2,
    dependencies: ['test-module-1'],
    conflicts: [],
    tags: ['test', 'domain', 'advanced'],
    metadata: {
      description: 'A domain test module',
      author: 'Test Author 2',
      category: Category.Frontend,
      weight: 20,
    },
    instructions: [
      {
        id: 'test-instruction-2',
        content: 'This is a domain instruction',
        merge_strategy: MergeStrategy.Append,
      },
    ],
  };

  const sampleModule3: ModuleSchema = {
    id: 'test-module-3',
    name: 'Test Module 3',
    type: ModuleType.Task,
    version: '1.5.0',
    priority: 1.5,
    dependencies: [],
    conflicts: ['test-module-1'],
    tags: ['test', 'task'],
    metadata: {
      description: 'A task test module',
      author: 'Test Author 3',
      category: Category.Backend,
      weight: 15,
    },
    instructions: [
      {
        id: 'test-instruction-3',
        content: 'This is a task instruction',
        merge_strategy: MergeStrategy.Prepend,
      },
    ],
  };

  beforeEach(() => {
    jest.resetAllMocks();
    jest.clearAllMocks();

    // Setup mock ModuleLoader
    mockModuleLoader = {
      discoverModules: jest.fn(),
      loadModule: jest.fn(),
      clearCache: jest.fn(),
    } as any;

    MockModuleLoader.mockImplementation(() => mockModuleLoader);

    // Setup validation mock to pass by default
    mockValidateModule.mockReturnValue({ valid: true, errors: [] });

    registry = new ModuleRegistry();
  });

  afterEach(() => {
    // Clear registry state to prevent test pollution
    if (registry) {
      registry.clear();
    }
    jest.clearAllTimers();
  });

  describe('Constructor', () => {
    it('should initialize with empty registry and all indexes', () => {
      expect(registry).toBeInstanceOf(ModuleRegistry);
      expect(registry.getAllModules()).toHaveLength(0);
    });

    it('should accept custom ModuleLoader instance', () => {
      const customLoader = new ModuleLoader();
      const customRegistry = new ModuleRegistry(customLoader);
      expect(customRegistry).toBeInstanceOf(ModuleRegistry);
    });
  });

  describe('registerModule', () => {
    it('should register a valid module successfully', () => {
      mockValidateModule.mockReturnValue({ valid: true, errors: [] });

      registry.registerModule(sampleModule1);

      expect(mockValidateModule).toHaveBeenCalledWith(sampleModule1, []);
      expect(registry.getModule('test-module-1')).toEqual(sampleModule1);
      expect(registry.getAllModules()).toHaveLength(1);
    });

    it('should throw ModuleRegistrationError for invalid module', () => {
      mockValidateModule.mockReturnValue({
        valid: false,
        errors: ['Invalid module schema'],
      });

      expect(() => registry.registerModule(sampleModule1)).toThrow(
        ModuleRegistrationError
      );
      expect(() => registry.registerModule(sampleModule1)).toThrow(
        'Validation failed: Invalid module schema'
      );
    });

    it('should throw ModuleRegistrationError for duplicate module ID', () => {
      registry.registerModule(sampleModule1);

      expect(() => registry.registerModule(sampleModule1)).toThrow(
        ModuleRegistrationError
      );
      expect(() => registry.registerModule(sampleModule1)).toThrow(
        'Module with this ID already exists in registry'
      );
    });

    it('should update all indexes when registering modules', () => {
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);

      // Test type index
      const baseModules = registry.findModules({ type: ModuleType.Base });
      expect(baseModules).toContain(sampleModule1);

      const domainModules = registry.findModules({ type: ModuleType.Domain });
      expect(domainModules).toContain(sampleModule2);
    });

    it('should validate against existing modules when registering', () => {
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);

      expect(mockValidateModule).toHaveBeenCalledWith(sampleModule2, [
        sampleModule1,
      ]);
    });
  });

  describe('getModule', () => {
    beforeEach(() => {
      registry.clear();
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);
    });

    it('should return module by ID if it exists', () => {
      const result = registry.getModule('test-module-1');
      expect(result).toEqual(sampleModule1);
    });

    it('should return undefined for non-existent module ID', () => {
      const result = registry.getModule('non-existent');
      expect(result).toBeUndefined();
    });
  });

  describe('findModules', () => {
    beforeEach(() => {
      registry.clear();
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);
      registry.registerModule(sampleModule3);
    });

    it('should find module by exact ID match', () => {
      const criteria: SearchCriteria = { id: 'test-module-1' };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule1);
    });

    it('should return empty array for non-existent ID', () => {
      const criteria: SearchCriteria = { id: 'non-existent' };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(0);
    });

    it('should find modules by type', () => {
      const criteria: SearchCriteria = { type: ModuleType.Base };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule1);
    });

    it('should find modules by category', () => {
      const criteria: SearchCriteria = { category: Category.Frontend };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule2);
    });

    it('should find modules by tags (all must match)', () => {
      const criteria: SearchCriteria = {
        tags: { all: ['test', 'base'] },
      };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule1);
    });

    it('should find modules by tags (any must match)', () => {
      const criteria: SearchCriteria = {
        tags: { any: ['domain', 'task'] },
      };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(2);
      expect(results).toContain(sampleModule2);
      expect(results).toContain(sampleModule3);
    });

    it('should find modules by dependencies', () => {
      const criteria: SearchCriteria = {
        dependencies: ['test-module-1'],
      };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule2);
    });

    it('should find modules by conflicts', () => {
      const criteria: SearchCriteria = {
        conflicts: ['test-module-1'],
      };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule3);
    });

    it('should find modules by name (partial match)', () => {
      const criteria: SearchCriteria = { name: 'Module 2' };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule2);
    });

    it('should find modules by description (partial match)', () => {
      const criteria: SearchCriteria = { description: 'domain' };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule2);
    });

    it('should find modules by author (partial match)', () => {
      const criteria: SearchCriteria = { author: 'Author 2' };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule2);
    });

    it('should find modules by version pattern', () => {
      const criteria: SearchCriteria = { version: '2.*' };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule2);
    });

    it('should combine multiple search criteria with AND logic', () => {
      const criteria: SearchCriteria = {
        type: ModuleType.Base,
        category: Category.General,
        tags: { all: ['test'] },
      };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule1);
    });

    it('should return empty array when no modules match criteria', () => {
      const criteria: SearchCriteria = {
        type: ModuleType.Base,
        category: Category.Frontend, // No base modules in frontend category
      };
      const results = registry.findModules(criteria);

      expect(results).toHaveLength(0);
    });
  });

  describe('getAllModules', () => {
    it('should return empty array when no modules are registered', () => {
      const result = registry.getAllModules();
      expect(result).toHaveLength(0);
    });

    it('should return all registered modules', () => {
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);

      const result = registry.getAllModules();
      expect(result).toHaveLength(2);
      expect(result).toContain(sampleModule1);
      expect(result).toContain(sampleModule2);
    });
  });

  describe('removeModule', () => {
    beforeEach(() => {
      // Ensure clean state
      registry.clear();
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);
    });

    it('should remove existing module and return true', () => {
      const result = registry.removeModule('test-module-1');

      expect(result).toBe(true);
      expect(registry.getModule('test-module-1')).toBeUndefined();
      expect(registry.getAllModules()).toHaveLength(1);
    });

    it('should return false when trying to remove non-existent module', () => {
      const result = registry.removeModule('non-existent');

      expect(result).toBe(false);
      expect(registry.getAllModules()).toHaveLength(2);
    });

    it('should update indexes when removing module', () => {
      // Verify initial state - should have one base module
      const initialBaseModules = registry.findModules({
        type: ModuleType.Base,
      });
      expect(initialBaseModules).toHaveLength(1);
      expect(initialBaseModules[0]?.id).toBe('test-module-1');

      // Remove the base module
      registry.removeModule('test-module-1');

      // Verify the base module is removed from the index
      const finalBaseModules = registry.findModules({
        type: ModuleType.Base,
      });
      expect(finalBaseModules).toHaveLength(0);

      // Verify the module is completely removed
      expect(registry.getModule('test-module-1')).toBeUndefined();

      // Verify other modules are still there
      expect(registry.getModule('test-module-2')).toBeDefined();
    });
  });

  describe('clear', () => {
    beforeEach(() => {
      registry.clear();
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);
    });

    it('should remove all modules and clear all indexes', () => {
      registry.clear();

      expect(registry.getAllModules()).toHaveLength(0);
      expect(registry.findModules({ type: ModuleType.Base })).toHaveLength(0);
      expect(registry.findModules({ type: ModuleType.Domain })).toHaveLength(0);
    });
  });

  describe('loadFromDirectory', () => {
    const testDirectory = '/test/modules';
    const mockFiles = ['module1.ts', 'module2.ts'];

    beforeEach(() => {
      mockModuleLoader.discoverModules.mockResolvedValue(mockFiles);
      mockModuleLoader.loadModule.mockImplementation((filePath: string) => {
        if (filePath.includes('module1')) {
          return Promise.resolve({ default: sampleModule1 });
        } else if (filePath.includes('module2')) {
          return Promise.resolve({ module: sampleModule2 });
        }
        return Promise.reject(new Error('Unknown module'));
      });
    });

    it('should load and register modules from directory', async () => {
      await registry.loadFromDirectory(testDirectory);

      expect(mockModuleLoader.discoverModules).toHaveBeenCalled();
      expect(mockModuleLoader.loadModule).toHaveBeenCalledTimes(2);
      expect(registry.getAllModules()).toHaveLength(2);
    });

    it('should handle individual module load failures gracefully', async () => {
      mockModuleLoader.loadModule.mockImplementation((filePath: string) => {
        if (filePath.includes('module1')) {
          return Promise.resolve({ default: sampleModule1 });
        }
        return Promise.reject(new Error('Load failed'));
      });

      await registry.loadFromDirectory(testDirectory);

      expect(registry.getAllModules()).toHaveLength(1);
      expect(registry.getModule('test-module-1')).toEqual(sampleModule1);
    });

    it('should throw ModuleDiscoveryError when directory discovery fails', async () => {
      const discoveryError = new ModuleDiscoveryError(
        testDirectory,
        new Error('Permission denied')
      );
      mockModuleLoader.discoverModules.mockRejectedValue(discoveryError);

      await expect(registry.loadFromDirectory(testDirectory)).rejects.toThrow(
        ModuleDiscoveryError
      );
    });

    it('should wrap unknown errors in ModuleDiscoveryError', async () => {
      mockModuleLoader.discoverModules.mockRejectedValue(
        new Error('Unknown error')
      );

      await expect(registry.loadFromDirectory(testDirectory)).rejects.toThrow(
        ModuleDiscoveryError
      );
    });
  });

  describe('saveRegistry', () => {
    const testFilePath = '/test/registry.json';

    beforeEach(() => {
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);
    });

    it('should save registry to JSON file', async () => {
      mockFs.mkdir.mockResolvedValue(undefined);
      mockFs.writeFile.mockResolvedValue();

      await registry.saveRegistry(testFilePath);

      expect(mockFs.mkdir).toHaveBeenCalledWith(path.dirname(testFilePath), {
        recursive: true,
      });
      expect(mockFs.writeFile).toHaveBeenCalledWith(
        testFilePath,
        expect.stringContaining('"modules"'),
        'utf-8'
      );
    });

    it('should throw ModuleRegistryIOError on save failure', async () => {
      const writeError = new Error('Permission denied');
      mockFs.mkdir.mockResolvedValue(undefined);
      mockFs.writeFile.mockRejectedValue(writeError);

      await expect(registry.saveRegistry(testFilePath)).rejects.toThrow(
        ModuleRegistryIOError
      );
    });
  });

  describe('loadRegistry', () => {
    const testFilePath = '/test/registry.json';

    it('should load registry from JSON file', async () => {
      const registryData = {
        version: '1.0.0',
        timestamp: new Date().toISOString(),
        modules: [sampleModule1, sampleModule2],
      };

      mockFs.readFile.mockResolvedValue(JSON.stringify(registryData));

      await registry.loadRegistry(testFilePath);

      expect(registry.getAllModules()).toHaveLength(2);
      expect(registry.getModule('test-module-1')).toEqual(sampleModule1);
      expect(registry.getModule('test-module-2')).toEqual(sampleModule2);
    });

    it('should throw ModuleRegistryIOError on read failure', async () => {
      const readError = new Error('File not found');
      mockFs.readFile.mockRejectedValue(readError);

      await expect(registry.loadRegistry(testFilePath)).rejects.toThrow(
        ModuleRegistryIOError
      );
    });

    it('should throw ModuleRegistryIOError on invalid JSON format', async () => {
      mockFs.readFile.mockResolvedValue('invalid json');

      await expect(registry.loadRegistry(testFilePath)).rejects.toThrow(
        ModuleRegistryIOError
      );
    });

    it('should handle invalid registry file format', async () => {
      const invalidData = { version: '1.0.0' }; // Missing modules array
      mockFs.readFile.mockResolvedValue(JSON.stringify(invalidData));

      await expect(registry.loadRegistry(testFilePath)).rejects.toThrow(
        ModuleRegistryIOError
      );
    });

    it('should handle individual module registration failures during load', async () => {
      const registryData = {
        version: '1.0.0',
        timestamp: new Date().toISOString(),
        modules: [sampleModule1, { invalid: 'module' }],
      };

      mockFs.readFile.mockResolvedValue(JSON.stringify(registryData));
      mockValidateModule.mockImplementation(module => {
        if ((module as any).invalid) {
          return { valid: false, errors: ['Invalid module'] };
        }
        return { valid: true, errors: [] };
      });

      await registry.loadRegistry(testFilePath);

      expect(registry.getAllModules()).toHaveLength(1);
      expect(registry.getModule('test-module-1')).toEqual(sampleModule1);
    });
  });

  describe('getStatistics', () => {
    beforeEach(() => {
      registry.clear();
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);
      registry.registerModule(sampleModule3);
    });

    it('should return comprehensive registry statistics', () => {
      const stats = registry.getStatistics();

      expect(stats.totalModules).toBe(3);
      expect(stats.modulesByType).toEqual({
        [ModuleType.Base]: 1,
        [ModuleType.Domain]: 1,
        [ModuleType.Task]: 1,
      });
      expect(stats.modulesByCategory).toEqual({
        [Category.General]: 1,
        [Category.Frontend]: 1,
        [Category.Backend]: 1,
      });
      expect(stats.topTags).toContainEqual({ tag: 'test', count: 3 });
    });

    it('should return empty statistics for empty registry', () => {
      const emptyRegistry = new ModuleRegistry();
      const stats = emptyRegistry.getStatistics();

      expect(stats.totalModules).toBe(0);
      expect(stats.modulesByType).toEqual({});
      expect(stats.modulesByCategory).toEqual({});
      expect(stats.topTags).toHaveLength(0);
    });
  });

  describe('Error Classes', () => {
    it('should create ModuleRegistryError with correct name and message', () => {
      const error = new ModuleRegistryError('Test error');
      expect(error.name).toBe('ModuleRegistryError');
      expect(error.message).toBe('Test error');
      expect(error).toBeInstanceOf(Error);
    });

    it('should create ModuleRegistrationError with module ID', () => {
      const error = new ModuleRegistrationError('test-module', 'Test reason');
      expect(error.name).toBe('ModuleRegistrationError');
      expect(error.moduleId).toBe('test-module');
      expect(error.message).toContain('test-module');
      expect(error.message).toContain('Test reason');
    });

    it('should create ModuleRegistryIOError with file path and operation', () => {
      const originalError = new Error('Original error');
      const error = new ModuleRegistryIOError(
        '/test/path',
        'read',
        originalError
      );

      expect(error.name).toBe('ModuleRegistryIOError');
      expect(error.filePath).toBe('/test/path');
      expect(error.message).toContain('/test/path');
      expect(error.message).toContain('read');
      expect(error.message).toContain('Original error');
    });
  });

  describe('Edge Cases and Integration', () => {
    it('should handle modules with no optional fields', () => {
      const minimalModule: ModuleSchema = {
        id: 'minimal-module',
        name: 'Minimal Module',
        type: ModuleType.Base,
        version: '1.0.0',
        priority: 1.0,
        metadata: {
          description: 'Minimal test module',
          author: 'Test Author',
          category: Category.General,
          weight: 5,
        },
        instructions: [
          {
            id: 'minimal-instruction',
            content: 'Minimal instruction',
            merge_strategy: MergeStrategy.Replace,
          },
        ],
      };

      registry.registerModule(minimalModule);
      expect(registry.getModule('minimal-module')).toEqual(minimalModule);
    });

    it('should handle complex search criteria combinations', () => {
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);
      registry.registerModule(sampleModule3);

      const complexCriteria: SearchCriteria = {
        tags: { all: ['test'], any: ['domain', 'task'] },
        category: Category.Frontend,
        author: 'Author',
      };

      const results = registry.findModules(complexCriteria);
      expect(results).toHaveLength(1);
      expect(results[0]).toEqual(sampleModule2);
    });

    it('should maintain index consistency after multiple operations', () => {
      // Ensure clean state
      registry.clear();

      // Register modules
      registry.registerModule(sampleModule1);
      registry.registerModule(sampleModule2);
      registry.registerModule(sampleModule3);

      // Remove one module
      registry.removeModule('test-module-2');

      // Verify indexes are updated correctly
      const domainModules = registry.findModules({ type: ModuleType.Domain });
      expect(domainModules).toHaveLength(0);

      const frontendModules = registry.findModules({
        category: Category.Frontend,
      });
      expect(frontendModules).toHaveLength(0);

      const dependentModules = registry.findModules({
        dependencies: ['test-module-1'],
      });
      expect(dependentModules).toHaveLength(0);
    });
  });
});
