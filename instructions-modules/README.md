# Instruction Modules

This directory contains a collection of instruction modules that provide guidance on various topics, including technology, foundational principles, and execution playbooks. These modules are designed to be used as a knowledge base for building intelligent agents.

The modules are organized into a hierarchical structure. Below is a list of all available modules.

---

## Execution

Playbooks for executing common tasks.

- **Meta**
  - [Module Integration Protocol](execution/meta/module-integration-protocol.md) - The core procedure for an AI agent to dynamically discover, select, and apply instruction modules to solve a user''s request.
- **Persona Builder**
  - [Foundation Layer Order Checklist](execution/persona-builder/foundation-layer-rules.md) - A checklist to verify that Foundation modules are ordered correctly by their layer metadata.
  - [Lint Persona File](execution/persona-builder/lint-persona-file.md) - A playbook to analyze a persona's module list and generate a comprehensive quality and consistency report.
  - [Module Tier Order Checklist](execution/persona-builder/four-tier-philosophy.md) - A checklist to verify that persona modules follow the strict hierarchical order: Foundation -> Principle -> Technology -> Execution.
- **Playbook**
  - [Debug an Issue](execution/playbook/debug-issue.md) - A systematic playbook for debugging, leveraging foundational modules like root-cause-analysis and causal-reasoning.
  - [Design Microservices Architecture](execution/playbook/design-microservices-architecture.md) - A playbook for designing a system based on the microservices architectural style.
  - [Document a Function](execution/playbook/document-a-function.md) - A playbook for writing comprehensive documentation for a given function, including its parameters, return value, and potential errors.
  - [Generate New Persona Module](execution/playbook/generate-new-persona-module.md) - A playbook for generating a new, complete persona file from a user's concept.
  - [Generate Secure Error Response](execution/playbook/generate-secure-error-response.md) - A step-by-step process for generating a user-safe error response while logging detailed internal diagnostics.
  - [Optimize Web Application Performance](execution/playbook/optimize-web-application-performance.md) - A playbook that applies performance principles to a concrete goal of optimizing a web application.
  - [Perform Security Audit](execution/playbook/security-audit.md) - A playbook for conducting a comprehensive security audit of a codebase to identify and mitigate vulnerabilities.
  - [Plan a Feature](execution/playbook/plan-a-feature.md) - A playbook for taking a user story and breaking it down into a technical implementation plan with concrete steps.
  - [Plan Legacy Modernization](execution/playbook/plan-legacy-modernization.md) - A playbook for creating a safe, incremental plan to modernize a legacy system.
  - [Refactor a Component](execution/playbook/refactor-component.md) - A step-by-step process for safely improving the internal structure of a piece of code without changing its external behavior.
  - [Review a Pull Request](execution/playbook/review-pull-request.md) - A playbook that uses a checklist to provide structured, constructive feedback on a pull request.
  - [Write a Commit Message](execution/playbook/write-commit-message.md) - A playbook for writing a well-formed Git commit message following the Conventional Commits standard.
  - **Audit Documentation**
    - [Playbook: Verify and Comment Documentation](execution/playbook/audit-documentation/verify-and-comment.md) - A step-by-step process for auditing documentation against a codebase.
  - **Modules**
    - [Generate New Instruction Module](execution/playbook/modules/generate-new-instruction-module.md) - A systematic playbook for creating well-structured instruction modules that follow the official schema requirements and machine-centric writing principles.
    - [Instruction Module Validation](execution/playbook/modules/instruction-module-validation.md) - A comprehensive checklist to validate that instruction modules conform to official schema requirements, frontmatter standards, and machine-centric language principles.
    - [Machine-Centric Language](execution/playbook/modules/machine-centric-language.md) - The three pillars of deterministic, precise, and structured language for writing effective AI instructions that eliminate ambiguity and ensure consistent execution.
- **Testing**
  - [Playbook: Debug Failing Unit Test](execution/testing/debug-failing-unit-test.md) - A playbook that uses root-cause-analysis to diagnose a failing test report from Vitest and propose a minimal, correct fix.
  - [Playbook: Refactor for Testability](execution/testing/refactor-to-use-mocks.md) - A playbook for analyzing a hard-to-test function and refactoring it to use dependency injection, then writing a new unit test using vi.mock.
  - [Playbook: Write New Unit Test](execution/testing/write-new-unit-test.md) - A step-by-step process for generating a new unit test file for a given source code function, strictly following the Arrange-Act-Assert pattern.

## Foundation

Core principles and concepts for reasoning, problem-solving, and decision-making.

- **Bias**
  - [Avoiding Survivorship Bias](foundation/bias/avoiding-survivorship-bias.md) - A rule to consider the data from failures as well as successes, avoiding the error of drawing conclusions only from surviving examples.
  - [Awareness of Availability Heuristic](foundation/bias/awareness-of-availability-heuristic.md) - Instructions to not overestimate the importance of information that comes to mind most easily.
  - [Ignoring Sunk Costs](foundation/bias/ignoring-sunk-costs.md) - A directive to make decisions based on future potential value, explicitly ignoring past, irrecoverable costs.
  - [Mitigating Confirmation Bias](foundation/bias/mitigating-confirmation-bias.md) - A directive to actively seek out, consider, and present disconfirming evidence.
  - [Recognizing Anchoring Bias](foundation/bias/recognizing-anchoring.md) - A rule to avoid over-relying on the first piece of information received.
- **Cognitive Frameworks**
  - [Chain of Verification](foundation/cognitive-frameworks/chain-of-verification.md) - A self-correction framework where the AI generates a draft answer, formulates verification questions about it, answers those questions internally, and then produces a final, verified response.
  - [Contrastive Reasoning](foundation/cognitive-frameworks/contrastive-reasoning.md) - A directive to improve reasoning clarity by generating both a correct and an intentionally incorrect example or reasoning path, then explaining why one is correct and the other is flawed.
  - [Graph of Thoughts](foundation/cognitive-frameworks/graph-of-thoughts.md) - An advanced reasoning framework that models thoughts as nodes in a graph, allowing for complex, non-linear reasoning paths that can merge and diverge to solve highly interconnected problems.
  - [ReAct Framework](foundation/cognitive-frameworks/re-act-framework.md) - A directive to solve problems by operating in a structured Thought -> Action -> Observation loop, allowing the AI to reason, use tools, and then reason again based on the outcome.
  - [Self-Consistency Voting](foundation/cognitive-frameworks/self-consistency-voting.md) - A technique to improve accuracy by generating multiple diverse reasoning paths for the same problem and then selecting the most frequent or consistent answer from the conclusions.
  - [Tree of Thoughts](foundation/cognitive-frameworks/tree-of-thoughts.md) - A framework for complex problem-solving that explores multiple reasoning paths simultaneously, evaluates their viability, and pursues only the most promising ones.
- **Communication**
  - [Ask Clarifying Questions](foundation/communication/ask-clarifying-questions.md) - A directive to seek more information when a user's request is ambiguous or incomplete.
  - [Clarity and Brevity](foundation/communication/clarity-and-brevity.md) - A set of rules for communicating in a way that is clear, concise, and unambiguous.
  - [Define Technical Terms in Software Development](foundation/communication/define-your-terms.md) - A specification for identifying and defining technical jargon, acronyms, and ambiguous terms in software development communications.
  - [Error Reporting](foundation/communication/error-reporting.md) - A directive to report errors in a way that is clear, informative, and actionable for the user.
  - [Structured Technical Arguments in Software Development](foundation/communication/structure-your-arguments.md) - A specification for presenting technical recommendations, architectural decisions, and implementation proposals with logical structure and evidence-based support.
- **Decision Making**
  - [Assess Risk and Uncertainty](foundation/decision-making/assess-risk-and-uncertainty.md) - A process to differentiate between risk (known probabilities) and uncertainty (unknown probabilities).
  - [One-Way vs. Two-Way Doors](foundation/decision-making/one-way-vs-two-way-doors.md) - A framework for classifying decisions based on their reversibility.
  - [Satisficing vs. Maximizing](foundation/decision-making/satisficing-vs-maximizing.md) - A rule to understand when a 'good enough' solution is superior to striving for a perfect one.
  - [Technical Cost-Benefit Analysis for Software Development](foundation/decision-making/cost-benefit-analysis.md) - A specification for systematically evaluating software development decisions by comparing technical costs against expected benefits using quantifiable metrics.
- **Ethics**
  - [Clarify and Correct](foundation/ethics/clarify-and-correct.md) - Instructions to admit when something is unknown or when a mistake has been made.
  - [Do No Harm](foundation/ethics/do-no-harm.md) - A fundamental principle to evaluate proposed actions and code for potential negative consequences, prioritizing safety and stability.
  - [Intellectual Honesty](foundation/ethics/intellectual-honesty.md) - A specification for representing facts, arguments, and evidence fairly, accurately, and without deception.
  - [Principle of Charity](foundation/ethics/principle-of-charity.md) - A rule to interpret a user's statements in their strongest, most reasonable form.
  - [Respect User Autonomy](foundation/ethics/respect-user-autonomy.md) - A directive to empower the user to make their own decisions, providing options and trade-offs rather than making choices on their behalf.
- **Logic**
  - [Avoiding Logical Fallacies in Software Development](foundation/logic/avoiding-logical-fallacies.md) - A specification for identifying and avoiding common logical errors in software development reasoning and argumentation.
  - [Causality vs. Correlation](foundation/logic/causality-vs-correlation.md) - A critical rule to not assume that one event causes another just because they are correlated.
  - [Conditional Logic (If-Then)](foundation/logic/if-then-statements.md) - Rules for correctly processing and evaluating conditional statements.
  - [Necessary and Sufficient Conditions](foundation/logic/necessary-and-sufficient-conditions.md) - A core logical framework for precisely analyzing the relationship between conditions and outcomes.
  - [Occam's Razor](foundation/logic/occam-s-razor.md) - The principle that, when presented with competing hypotheses, the one with the fewest assumptions should be selected.
  - [Proof Verification](foundation/logic/proof-verification.md) - A process for systematically checking the validity of a logical argument or proof by examining its premises and deductive steps.
  - [Quantifiers and Scope](foundation/logic/quantifiers-and-scope.md) - A rule to be precise with logical quantifiers (e.g., 'all,' 'some,' 'none') and to clearly define their scope.
- **Metacognition**
  - [Continuous Improvement](foundation/metacognition/continuous-improvement.md) - A meta-cognitive mindset focused on ongoing learning by reflecting on experiences, seeking feedback, and deliberately practicing new skills.
  - [Distinguishing Fact from Opinion](foundation/metacognition/distinguishing-fact-from-opinion.md) - A core rule to clearly separate objective, verifiable facts from subjective opinions or beliefs.
  - [Evaluating Confidence Levels](foundation/metacognition/evaluating-confidence-levels.md) - A process for assessing and stating the level of confidence in a conclusion.
  - [Evaluating Technical Evidence in Software Development](foundation/metacognition/evaluating-evidence.md) - A specification for assessing the quality, reliability, and relevance of technical information and data in software development contexts.
  - [Growth Mindset](foundation/metacognition/growth-mindset.md) - The principle of viewing challenges as opportunities to learn and grow, rather than as threats to one's competence.
  - [Re-read for Comprehension in Software Development](foundation/metacognition/re-read-for-comprehension.md) - A meta-cognitive procedure for thoroughly reviewing all requirements, constraints, and context before implementing any software solution.
  - [Self-Correction Process](foundation/metacognition/self-correction-process.md) - A process for systematically identifying and correcting technical errors, logical flaws, and incomplete analysis in software development reasoning and implementation decisions.
  - [The Feynman Technique](foundation/metacognition/the-feynman-technique.md) - A process for testing and validating understanding of software development concepts by explaining them in simple, clear terms without jargon or technical assumptions.
  - [Understanding Levels of Certainty](foundation/metacognition/understanding-levels-of-certainty.md) - A specification for classifying and communicating the certainty of technical claims, from speculation to established facts.
  - [Weighing Trade-Offs](foundation/metacognition/weighing-trade-offs.md) - A process for systematically analyzing the technical trade-offs, constraints, and implications of different software development options and architectural decisions.
- **Problem Solving**
  - [Identify the Bottleneck](foundation/problem-solving/identify-the-bottleneck.md) - A process for analyzing a system to find the single constraint that limits its overall performance.
  - [Means-End Analysis](foundation/problem-solving/means-end-analysis.md) - A process for systematically reducing the difference between the current state and the goal state.
  - [Problem Deconstruction](foundation/problem-solving/problem-deconstruction.md) - The process of breaking large, complex problems into smaller, more manageable, and mutually exclusive parts.
  - [Root Cause Analysis](foundation/problem-solving/root-cause-analysis.md) - A systematic process to look beyond immediate symptoms and find the underlying, fundamental cause of a problem.
  - [Rubber Duck Debugging](foundation/problem-solving/rubber-duck-debugging.md) - A meta-cognitive technique for solving problems by explaining the code, line-by-line, to an inanimate object.
  - [Time-boxing](foundation/problem-solving/time-boxing.md) - A technique for managing effort and focus by allocating a fixed time period to a specific task or approach.
  - [Using Heuristics](foundation/problem-solving/using-heuristics.md) - A directive to use rules of thumb and educated guesses to find approximate solutions when a problem is computationally expensive.
  - [Work Backwards from Goal](foundation/problem-solving/work-backwards.md) - A strategy of starting from the desired outcome to determine the necessary preceding steps.
- **Reasoning**
  - [Abductive Reasoning](foundation/reasoning/abductive-reasoning.md) - A procedure for generating the most likely hypothesis for a set of observations by favoring the simplest explanation.
  - [Analogical Reasoning](foundation/reasoning/analogical-reasoning.md) - A cognitive process for transferring knowledge and solutions from one domain to solve problems in another domain by mapping structural relationships.
  - [Causal Reasoning](foundation/reasoning/causal-reasoning.md) - A process for determining cause-and-effect relationships, moving beyond mere correlation by identifying mechanisms.
  - [Constraint Satisfaction](foundation/reasoning/constraint-satisfaction.md) - A process for finding a solution to a problem by identifying its variables, domains, and constraints, and finding an assignment that satisfies all constraints.
  - [Divergent Thinking](foundation/reasoning/divergent-thinking.md) - A cognitive process for generating a wide variety of possible solutions to a problem without initial judgment or criticism.
  - [Edge Case Analysis](foundation/reasoning/edge-case-analysis.md) - A systematic process for identifying and generating test cases for boundary conditions and non-standard inputs.
  - [Fundamental Technical Reasoning for Software Development](foundation/reasoning/first-principles-thinking.md) - A specification for deconstructing software engineering problems to their fundamental computational, mathematical, and empirical principles rather than relying on frameworks, patterns, or industry conventions.
  - [Inductive Reasoning](foundation/reasoning/inductive-reasoning.md) - Forming broad generalizations based on specific observations.
  - [Systems Thinking](foundation/reasoning/systems-thinking.md) - A procedure for analyzing problems holistically by mapping system components, their interconnections, and identifying key leverage points like feedback loops and bottlenecks.
- **Software**
  - **Logic**
    - [Deductive Reasoning for Code](foundation/software/logic/deductive-reasoning.md) - A process for deriving logically certain conclusions about a system''s state from general rules and specific conditions.

## Principle

Guiding principles for software development, architecture, and process.

- **Architecture**
  - [API Design Principles](principle/architecture/api-design-principles.md) - A specification for designing clean, consistent, and easy-to-use RESTful APIs.
  - [Architecture Decision Records (ADRs)](principle/architecture/architecture-decision-records.md) - A documentation pattern for capturing significant architectural decisions, their context, and consequences in a structured, lightweight format.
  - [Command-Query Responsibility Segregation (CQRS)](principle/architecture/command-query-responsibility-segregation.md) - The principle that separates methods that change state (Commands) from methods that read state (Queries). This can improve performance, scalability, and security.
  - [Design for Scalability](principle/architecture/design-for-scalability.md) - The principle of designing systems that can handle increased load by adding resources, typically horizontally.
  - [Domain-Driven Design (DDD)](principle/architecture/domain-driven-design.md) - An architectural approach that aligns software design with business domain complexity through shared language, strategic modeling, and tactical design patterns.
  - [Event-Driven Architecture](principle/architecture/event-driven-architecture.md) - An architectural pattern where components communicate through asynchronous events, enabling loose coupling, scalability, and reactive system design.
  - [Hexagonal Architecture (Ports and Adapters)](principle/architecture/hexagonal-architecture.md) - An architectural pattern that isolates the application core from external services through well-defined interfaces (ports) and implementations (adapters).
  - [Layered Architecture](principle/architecture/layered-architecture.md) - An architectural pattern that organizes software systems into horizontal layers with specific responsibilities, where each layer depends only on the layer immediately below it to enforce separation of concerns and maintainability.
  - [Microservices Architecture](principle/architecture/microservices.md) - An architectural pattern that decomposes applications into a collection of loosely coupled, independently deployable services organized around business capabilities.
  - [Principle of Least Astonishment](principle/architecture/principle-of-least-astonishment.md) - A rule that a system's components should behave in a way that users expect, without surprising them. The goal is to reduce the cognitive load required to use the system correctly.
  - [Robustness Principle (Postel's Law)](principle/architecture/robustness-principle.md) - A design principle for software implementation that states to 'be conservative in what you do, be liberal in what you accept from others.' This helps build resilient systems that can handle imperfect input.
  - [Separation of Concerns](principle/architecture/separation-of-concerns.md) - An architectural pattern that divides software systems into distinct components where each component addresses a single, well-defined responsibility or concern.
- **Collaboration**
  - [Effective Communication](principle/collaboration/effective-communication.md) - A set of principles for clear, concise, and effective technical communication with team members and stakeholders.
  - [Escalation Protocol (Asking for Help)](principle/collaboration/escalation-protocol.md) - A protocol for recognizing when to stop working alone and when to escalate a problem to a human user or another expert.
  - [Knowledge Sharing](principle/collaboration/knowledge-sharing.md) - Principles for actively mentoring, documenting, and sharing technical knowledge to improve a team's collective capability.
  - [Request for Comments (RFC) Process](principle/collaboration/request-for-comments-process.md) - A formal process for proposing and building consensus on significant technical changes by inviting feedback from a wide audience.
- **Design Patterns**
  - [Composition Over Inheritance Principle](principle/design-patterns/composition-over-inheritance.md) - A design principle stating that systems should achieve polymorphic behavior and code reuse by containing instances of other classes rather than inheriting from a base class.
  - [KISS (Keep It Simple, Stupid) Principle](principle/design-patterns/kiss-principle.md) - A design principle stating that most systems work best if they are kept simple rather than made unnecessarily complicated, prioritizing clarity and maintainability.
  - [Law of Demeter (Principle of Least Knowledge)](principle/design-patterns/law-of-demeter.md) - A design principle that reduces coupling by restricting a method from accessing objects deep within another object's structure.
  - **Behavioral**
    - [Command Pattern](principle/design-patterns/behavioral/command-pattern.md) - A behavioral design pattern that encapsulates requests as objects, enabling parameterization of clients with different requests, queuing operations, logging requests, and supporting undo functionality.
    - [Template Method Pattern](principle/design-patterns/behavioral/template-method-pattern.md) - A behavioral design pattern that defines the skeleton of an algorithm in a base class, allowing subclasses to override specific steps without changing the overall algorithm structure.
  - **Creational**
    - [Builder Pattern](principle/design-patterns/creational/builder-pattern.md) - A creational design pattern that constructs complex objects step by step, separating the construction process from the representation to enable flexible object creation with optional parameters.
    - [Factory Pattern](principle/design-patterns/creational/factory-pattern.md) - A creational design pattern that provides an interface for creating objects without specifying their exact classes, enabling loose coupling between client code and object creation logic.
    - [Observer Pattern](principle/design-patterns/creational/observer-pattern.md) - A behavioral design pattern where a subject object maintains a list of its dependent observers and notifies them automatically of any state changes.
    - [Singleton Pattern](principle/design-patterns/creational/singleton-pattern.md) - A creational design pattern that ensures a class has only one instance and provides a single, global point of access to it.
    - [Strategy Pattern](principle/design-patterns/creational/strategy-pattern.md) - A behavioral design pattern that defines a family of interchangeable algorithms, encapsulates each one, and allows them to be selected at runtime.
  - **Structural**
    - [Adapter Pattern](principle/design-patterns/structural/adapter-pattern.md) - A structural design pattern that allows incompatible interfaces to work together by creating a wrapper that translates one interface to another, enabling integration of existing classes without modifying their source code.
    - [Decorator Pattern](principle/design-patterns/structural/decorator-pattern.md) - A structural design pattern that allows adding new functionality to objects dynamically by wrapping them in decorator objects that implement the same interface, providing a flexible alternative to subclassing.
    - [Facade Pattern](principle/design-patterns/structural/facade-pattern.md) - A structural design pattern that provides a simplified interface to a complex subsystem by hiding its complexity behind a unified, easy-to-use interface that coordinates interactions between multiple components.
- **Documentation**
  - [Documentation Must Match Code](principle/documentation/1-docs-must-match-code.md) - A core principle that documentation must accurately reflect the current implementation, not future aspirations.
  - [Documentation Standards](principle/documentation/documentation-standards.md) - A set of standards for writing and maintaining clear, accurate, and useful documentation for a software project.
- **Methodology**
  - [Continuous Integration & Delivery (CI/CD)](principle/methodology/continuous-integration-delivery.md) - A set of practices that automate the integration, building, testing, and deployment of software to enable rapid and reliable releases.
  - [Feature Toggles (Feature Flags)](principle/methodology/feature-toggles.md) - A technique that decouples code deployment from feature release, allowing new functionality to be deployed to production in a disabled state.
  - [Infrastructure as Code (IaC)](principle/methodology/infrastructure-as-code.md) - The practice of defining and managing infrastructure using declarative configuration files, enabling version control and reproducibility.
  - [Iterative Development](principle/methodology/iterative-development.md) - The practice of building software in small, incremental cycles that deliver working functionality, enabling rapid feedback and adaptation.
  - [User Story Mapping](principle/methodology/user-story-mapping.md) - A technique for expressing requirements from the user's perspective, focusing on value rather than technical implementation.
- **Performance**
  - [Design for Performance](principle/performance/design-for-performance.md) - The principle of intentionally designing for efficiency in response time, throughput, and resource utilization.
  - [Optimization Principles](principle/performance/optimization-principles.md) - A set of guiding principles for improving system performance, emphasizing measurement and focusing on bottlenecks.
- **Process**
  - [Agile (Scrum)](principle/process/agile-scrum.md) - An iterative and incremental framework for project management and software development, focused on delivering value in small increments (Sprints) and adapting to change.
  - [Boy Scout Rule](principle/process/boy-scout-rule.md) - The principle that one should always leave the codebase cleaner than they found it. This encourages continuous, incremental improvement of code quality.
  - [Test-Driven Development (TDD)](principle/process/test-driven-development.md) - A software development process where tests are written before the code that they are intended to validate. The process is a short, repeating cycle of Red-Green-Refactor.
  - [YAGNI (You Ain't Gonna Need It)](principle/process/yagni.md) - The principle of not adding functionality until it is demonstrably necessary to avoid over-engineering.
  - **Modules**
    - [Module Authoring Principles](principle/process/modules/module-authoring-principles.md) - A procedure for authoring high-quality, machine-centric instruction modules that conform to the system's standards.
    - [Module Concept Checklist](principle/process/modules/module-concept-checklist.md) - A checklist to validate that a proposed module concept is atomic, clear, and adds value to the system.
    - [Schema Selection Procedure](principle/process/modules/schema-selection-procedure.md) - A deterministic procedure for selecting the correct module schema based on its primary purpose.
- **Quality**
  - [Clean Code Principles](principle/quality/clean-code-principles.md) - A software development philosophy emphasizing code readability, maintainability, and simplicity through consistent naming, minimal complexity, and self-documenting practices.
  - [Code Organization Pattern](principle/quality/code-organization.md) - The principle of structuring a codebase for clarity, logical cohesion, and maintainability.
  - [Code Review Checklist](principle/quality/code-review-checklist.md) - A systematic checklist for reviewing code, focusing on readability, maintainability, and correctness.
  - [Code Review Process](principle/quality/code-review-process.md) - The principle of implementing a thorough peer review process to catch issues before they enter the codebase.
  - [DRY (Don't Repeat Yourself) Principle](principle/quality/dry-principle.md) - A fundamental principle requiring that every piece of knowledge, logic, or data must have a single, unambiguous, authoritative representation within a system.
  - [Single Source of Truth (SSoT)](principle/quality/single-source-of-truth.md) - Software architecture principle requiring that every data element, business rule, and system configuration must be stored in exactly one authoritative location to ensure data integrity, consistency, and eliminate synchronization conflicts.
  - [SOLID Design Philosophy](principle/quality/solid-principles.md) - A design philosophy comprising five fundamental principles for creating maintainable, scalable, and robust object-oriented software architecture.
  - [Static Analysis Integration](principle/quality/static-analysis-integration.md) - The principle of using automated tools to identify potential issues in code before it is executed.
  - [Technical Debt Management](principle/quality/technical-debt-management.md) - A proactive process for identifying, tracking, and paying down technical debt to maintain long-term codebase health.
- **Reliability**
  - [Chaos Engineering](principle/reliability/chaos-engineering.md) - The practice of proactively testing system resilience by introducing controlled, deliberate failures into a production environment.
  - [Design for Reliability](principle/reliability/design-for-reliability.md) - The principle of designing systems that function correctly and consistently, even under adverse conditions.
  - [Fault Tolerance Design](principle/reliability/fault-tolerance-design.md) - Principles for designing systems that can continue to function correctly despite the failure of one or more of their components.
- **Security**
  - [Defense in Depth](principle/security/defense-in-depth.md) - The strategy of protecting a system with multiple, redundant layers of security controls, such that if one layer fails, another is in place to thwart an attack.
  - [Fail-Safe Defaults](principle/security/fail-safe-defaults.md) - The principle that, unless a subject is given explicit access to an object, it should be denied access. This is the foundation of a secure system.
  - [Principle of Least Privilege](principle/security/principle-of-least-privilege.md) - A security principle stating that any user, program, or process should have only the bare minimum privileges necessary to perform its function.
  - [Threat Modeling Process](principle/security/threat-modeling-process.md) - A systematic process for identifying, assessing, and mitigating potential security threats during the design phase of a system.
- **Testing**
  - [Arrange-Act-Assert (AAA) Pattern](principle/testing/arrange-act-assert-pattern.md) - A mandatory structural pattern for all unit tests to ensure clarity, consistency, and readability.
  - [Binary Debugging](principle/testing/binary-debugging.md) - A systematic procedure for isolating the source of a bug by repeatedly dividing the problem space.
  - [Design for Testability](principle/testing/design-for-testability.md) - A design philosophy that emphasizes writing code in a way that makes it easy to write high-quality, isolated unit tests.
  - [Test Isolation](principle/testing/test-isolation.md) - The critical principle that automated tests must be independent and not rely on a shared state or a specific execution order.
  - [The Testing Pyramid](principle/testing/testing-pyramid.md) - A strategic model for creating a balanced and effective testing portfolio with a focus on speed and reliability.

## Technology

Guidance on specific technologies, languages, and platforms.

- **Database**
  - **Postgresql**
    - [PostgreSQL Query Optimization](technology/database/postgresql/query-optimization.md) - Directives for writing efficient and performant queries in PostgreSQL, focusing on indexing, joins, and query analysis.
- **Framework**
  - **React**
    - [React Component Best Practices](technology/framework/react/component-best-practices.md) - Rules for component composition, state management, and props to create maintainable and performant React applications.
    - [React State Management Decisions](technology/framework/react/state-management-decisions.md) - A decision-tree module for choosing between useState, useReducer, useContext, and external libraries.
    - [React: Handling Side Effects with useEffect](technology/framework/react/useEffect-for-side-effects.md) - A specification for using the useEffect hook to manage side effects, dependencies, and cleanup.
    - [React: Rules of Hooks](technology/framework/react/rules-of-hooks.md) - The two fundamental rules for using React Hooks correctly.
- **Language**
  - **Python**
    - [Effective Python Error Handling](technology/language/python/effective-error-handling.md) - Directives on using try/except/finally blocks correctly and creating custom exceptions.
    - [PEP 8 Style Guide](technology/language/python/pep8-style.md) - A strict rulebook for ensuring all Python code is compliant with the PEP 8 style guide.
  - **Typescript**
    - [TypeScript: Async/Await with Types](technology/language/typescript/async-await-with-types.md) - A guide to correctly typing asynchronous functions and handling Promises to ensure type safety.
    - [TypeScript: Effective Generics](technology/language/typescript/effective-generics.md) - Best practices for using generics (<T>) to create reusable, type-safe functions, classes, and components.
    - [TypeScript: Enums and Discriminated Unions](technology/language/typescript/enums-and-discriminated-unions.md) - A guide for using enums and discriminated unions to create type-safe state machines and variant types.
    - [TypeScript: Module Resolution and Paths](technology/language/typescript/module-resolution-and-paths.md) - A guide to configuring tsconfig.json for robust module resolution and path aliasing.
    - [TypeScript: Strict Type-Checking](technology/language/typescript/strict-type-checking.md) - A rule enforcing the use of strict type-checking options in tsconfig.json to catch common errors at compile time.
    - [TypeScript: Type Guards and Narrowing](technology/language/typescript/type-guards-and-narrowing.md) - A guide to using type guards to narrow down the type of a variable within a conditional block.
    - [TypeScript: Types vs. Interfaces](technology/language/typescript/types-vs-interfaces.md) - A decision-making guide on when to use type aliases versus interface declarations for defining object shapes.
    - [TypeScript: Utility Types Best Practices](technology/language/typescript/utility-types-best-practices.md) - A guide to effectively using TypeScript's built-in utility types (Partial, Pick, Omit, Record, etc.) to manipulate and create new types.
- **Platform**
  - **Aws**
    - [API Gateway Integration Patterns](technology/platform/aws/api-gateway-integration-patterns.md) - A guide to different integration patterns for API Gateway, such as Lambda Proxy integration, HTTP integration, and AWS service integration.
    - [AWS IAM Best Practices](technology/platform/aws/iam-best-practices.md) - A set of security best practices for managing users, groups, roles, and permissions in AWS Identity and Access Management (IAM).
    - [AWS Lambda Best Practices](technology/platform/aws/lambda-best-practices.md) - A set of best practices for writing, configuring, and deploying efficient, secure, and cost-effective AWS Lambda functions.
    - [AWS S3 Storage Classes](technology/platform/aws/s3-storage-classes.md) - A decision-making guide for selecting the appropriate Amazon S3 storage class based on access frequency and cost considerations.
    - [DynamoDB Data Modeling](technology/platform/aws/dynamodb-data-modeling.md) - A module on how to model data effectively for DynamoDB, focusing on single-table design, access patterns, and choosing the right keys and indexes.
    - [VPC Network Security](technology/platform/aws/vpc-network-security.md) - A guide to securing an AWS Virtual Private Cloud (VPC) using security groups, network ACLs, and public/private subnets.
  - **Firebase**
    - [Cloud Functions for Firebase Best Practices](technology/platform/firebase/cloud-functions-best-practices.md) - Rules for writing efficient, secure, and idempotent Cloud Functions for Firebase.
    - [Firebase Authentication Best Practices](technology/platform/firebase/authentication-best-practices.md) - Best practices for implementing and managing user authentication with Firebase Auth.
    - [Firestore Data Modeling](technology/platform/firebase/firestore-data-modeling.md) - Principles for structuring data in Firestore for scalability and efficient querying, focusing on collections, documents, and subcollections.
    - [Firestore Security Rules](technology/platform/firebase/firestore-security-rules.md) - A critical guide for writing and testing Firestore security rules to protect data from unauthorized access.
  - **Vercel**
    - [Vercel Deployment Best Practices](technology/platform/vercel/deployment-best-practices.md) - A set of rules and processes for deploying applications to Vercel, focusing on performance, environment variables, and caching.
- **Security**
  - **Owasp Top 10**
    - [Broken Access Control](technology/security/owasp-top-10/broken-access-control.md) - A set of strict rules to prevent broken access control vulnerabilities by enforcing a default-deny policy and verifying authorization for every request.
    - [Cryptographic Failures](technology/security/owasp-top-10/cryptographic-failures.md) - A set of strict rules to prevent cryptographic failures by protecting data in transit and at rest using up-to-date, strong cryptographic algorithms and protocols.
    - [Identification and Authentication Failures](technology/security/owasp-top-10/identification-and-authentication-failures.md) - A set of rules to prevent authentication failures by implementing strong identity and session management controls.
    - [Injection](technology/security/owasp-top-10/injection.md) - A set of strict rules to prevent injection vulnerabilities by treating all user-supplied data as untrusted and using structured, safe APIs for all interpreter interactions.
    - [Insecure Design](technology/security/owasp-top-10/insecure-design.md) - A set of principles for secure software design, emphasizing threat modeling and the integration of security into every phase of the development lifecycle.
    - [Security Logging and Monitoring Failures](technology/security/owasp-top-10/security-logging-and-monitoring-failures.md) - A set of rules to ensure sufficient logging and monitoring is in place to detect and respond to security incidents in a timely manner.
    - [Security Misconfiguration](technology/security/owasp-top-10/security-misconfiguration.md) - A set of rules to prevent security misconfigurations by establishing a hardened, repeatable configuration process and regularly auditing the system for deviations.
    - [Server-Side Request Forgery (SSRF)](technology/security/owasp-top-10/server-side-request-forgery.md) - A set of rules to prevent Server-Side Request Forgery (SSRF) vulnerabilities by validating all user-supplied URLs and restricting the server's ability to make arbitrary network requests.
    - [Software and Data Integrity Failures](technology/security/owasp-top-10/software-and-data-integrity-failures.md) - A set of rules to protect against software and data integrity failures by verifying the integrity of all code, data, and critical updates.
    - [SQL Injection Prevention](technology/security/owasp-top-10/sql-injection-prevention.md) - A set of strict rules to prevent SQL injection vulnerabilities by never using dynamic query concatenation and always using parameterized queries.
    - [Vulnerable and Outdated Components](technology/security/owasp-top-10/vulnerable-and-outdated-components.md) - A set of rules for managing third-party components to prevent the use of software with known vulnerabilities.
- **Testing**
  - [Test Data Management with Fixtures](technology/testing/test-data-management.md) - A conceptual pattern for using test fixtures to create consistent, reusable, and maintainable test data.
  - **Cypress**
    - [Cypress Best Practices](technology/testing/cypress/best-practices.md) - A guide to best practices for writing reliable, maintainable, and effective end-to-end tests with Cypress.
    - [Cypress Custom Commands](technology/testing/cypress/custom-commands.md) - A guide to creating and using custom commands in Cypress to promote reusable and readable test code.
    - [Cypress Selector Strategies](technology/testing/cypress/selector-strategies.md) - A guide to the best strategies for selecting elements in Cypress tests to create stable and resilient tests.
  - **Jest**
    - [Jest Best Practices](technology/testing/jest/best-practices.md) - A guide to best practices for writing clean, effective, and maintainable tests with Jest.
    - [Jest Mocking](technology/testing/jest/mocking.md) - A guide to effectively using mocking in Jest to isolate components and functions for focused testing.
    - [Jest Snapshot Testing](technology/testing/jest/snapshot-testing.md) - Guidelines for using snapshot tests in Jest to verify the output of UI components and large data structures.
  - **Vitest**
    - [Vitest Async Testing](technology/testing/vitest/async-testing.md) - A guide to testing asynchronous operations including promises, async/await, and time-dependent code in Vitest.
    - [Vitest Configuration](technology/testing/vitest/vitest-configuration.md) - A guide to setting up vitest.config.ts with proper TypeScript, coverage, and environment configuration for optimal testing.
    - [Vitest Error Testing](technology/testing/vitest/error-testing.md) - A guide to testing error conditions, exception handling, and failure scenarios to ensure robust error handling in applications.
    - [Vitest Performance](technology/testing/vitest/performance.md) - Tips for writing performant tests in Vitest to ensure a fast and efficient testing cycle.
    - [Vitest Test Organization](technology/testing/vitest/test-organization.md) - A guide to structuring test files, naming conventions, and test suite organization for maintainable and scalable test suites.
    - [Vitest Test Utilities](technology/testing/vitest/test-utilities.md) - A guide to creating reusable test helpers, factories, and custom matchers to reduce duplication and improve test maintainability.
    - [Vitest: Best Practices](technology/testing/vitest/best-practices.md) - A guide to best practices for writing clean, effective, and maintainable tests with Vitest.
    - [Vitest: Controlling Time with Fake Timers](technology/testing/vitest/timers-and-fakes.md) - A guide on using vi.useFakeTimers() to reliably test time-based logic like setTimeout and setInterval.
    - [Vitest: Mocking with vi](technology/testing/vitest/mocking-with-vi.md) - A procedure for using the `vi` utility to create mocks for external dependencies, ensuring unit tests are isolated and deterministic.
- **Tool**
  - **Git**
    - [Conventional Commits Specification](technology/tool/git/conventional-commits.md) - A specification for writing commit messages that creates an explicit and machine-readable commit history.
    - [Interactive Rebase Workflow](technology/tool/git/interactive-rebase-workflow.md) - A process for cleaning up commit history using interactive rebase before merging a feature branch.
