// Generated by Claude Sonnet 4 on 6/30/2025, 8:50:45 PM
// Core ModuleRegistry class for task 1.2.3 - module indexing, search, and metadata management

import * as fs from 'fs/promises';
import * as path from 'path';
import { ModuleLoader } from './module-loader';
import { validateModule } from './module-validator';
import {
  ModuleDiscoveryError,
  ModuleLoaderError,
} from './module-loader-errors';
import type { ModuleSchema, ModuleType, Category } from '../types/module';

/**
 * Search criteria for finding modules in the registry
 */
export interface SearchCriteria {
  /** Search by module ID (exact match) */
  id?: string;
  /** Search by module name (partial match) */
  name?: string;
  /** Search by module type */
  type?: ModuleType;
  /** Search by category */
  category?: Category;
  /** Search by tags (AND/OR operations) */
  tags?: {
    /** Tags that must all be present (AND operation) */
    all?: string[];
    /** Tags where at least one must be present (OR operation) */
    any?: string[];
  };
  /** Text search in descriptions */
  description?: string;
  /** Search by dependencies */
  dependencies?: string[];
  /** Search by conflicts */
  conflicts?: string[];
  /** Search by author */
  author?: string;
  /** Search by version pattern */
  version?: string;
}

/**
 * Registry error classes extending the existing error hierarchy
 */
export class ModuleRegistryError extends ModuleLoaderError {
  constructor(message: string) {
    super(message);
    this.name = this.constructor.name;
  }
}

export class ModuleRegistrationError extends ModuleRegistryError {
  public readonly moduleId: string;
  constructor(moduleId: string, reason: string) {
    super(`Failed to register module '${moduleId}': ${reason}`);
    this.moduleId = moduleId;
  }
}

export class ModuleRegistryIOError extends ModuleRegistryError {
  public readonly filePath: string;
  constructor(filePath: string, operation: string, originalError?: Error) {
    let message = `Failed to ${operation} registry file: ${filePath}`;
    if (originalError) {
      message += `. Reason: ${originalError.message}`;
    }
    super(message);
    this.filePath = filePath;
    if (originalError && originalError.stack) {
      this.stack = originalError.stack;
    }
  }
}

/**
 * ModuleRegistry provides comprehensive module indexing, search, and metadata management
 * with efficient data structures and integration with existing ModuleLoader and validation systems.
 */
export class ModuleRegistry {
  /** Main storage for modules indexed by ID */
  private readonly modules: Map<string, ModuleSchema>;

  /** Index by module type for efficient type-based searches */
  private readonly typeIndex: Map<ModuleType, Set<string>>;

  /** Index by category for efficient category-based searches */
  private readonly categoryIndex: Map<Category, Set<string>>;

  /** Index by tags for efficient tag-based searches */
  private readonly tagIndex: Map<string, Set<string>>;

  /** Index by dependencies for efficient dependency queries */
  private readonly dependencyIndex: Map<string, Set<string>>;

  /** Index by conflicts for efficient conflict queries */
  private readonly conflictIndex: Map<string, Set<string>>;

  /** ModuleLoader instance for file system operations */
  private readonly _moduleLoader: ModuleLoader;

  /**
   * Creates a new ModuleRegistry instance
   * @param moduleLoader Optional ModuleLoader instance, creates default if not provided
   */
  constructor(moduleLoader?: ModuleLoader) {
    this.modules = new Map();
    this.typeIndex = new Map();
    this.categoryIndex = new Map();
    this.tagIndex = new Map();
    this.dependencyIndex = new Map();
    this.conflictIndex = new Map();
    this._moduleLoader = moduleLoader || new ModuleLoader();

    console.log(
      'ModuleRegistry initialized with comprehensive indexing system'
    );
    // Note: _moduleLoader available for future extensions
    void this._moduleLoader;
  }

  /**
   * Registers a module in the registry with validation and indexing
   * @param module Module to register
   * @throws ModuleRegistrationError if module is invalid or registration fails
   */
  registerModule(module: ModuleSchema): void {
    // Validate the module first
    const validation = validateModule(
      module,
      Array.from(this.modules.values())
    );
    if (!validation.valid) {
      throw new ModuleRegistrationError(
        module.id,
        `Validation failed: ${validation.errors.join(', ')}`
      );
    }

    // Check for duplicate ID
    if (this.modules.has(module.id)) {
      throw new ModuleRegistrationError(
        module.id,
        'Module with this ID already exists in registry'
      );
    }

    try {
      // Store the module
      this.modules.set(module.id, module);

      // Update all indexes
      this.addToIndexes(module);

      console.log(`Module '${module.id}' registered successfully`);
    } catch (error) {
      // Rollback if indexing fails
      this.modules.delete(module.id);
      throw new ModuleRegistrationError(
        module.id,
        `Failed to update indexes: ${
          error instanceof Error ? error.message : 'Unknown error'
        }`
      );
    }
  }

  /**
   * Retrieves a module by its ID
   * @param id Module ID to retrieve
   * @returns Module if found, undefined otherwise
   */
  getModule(id: string): ModuleSchema | undefined {
    return this.modules.get(id);
  }

  /**
   * Finds modules matching the specified search criteria
   * @param criteria Search criteria to match against
   * @returns Array of matching modules
   */
  findModules(criteria: SearchCriteria): ModuleSchema[] {
    let candidateIds: Set<string> | undefined;
    let indexBasedSearch = false;

    // Start with the most restrictive search to minimize candidates
    if (criteria.id) {
      // Exact ID match - most restrictive
      const module = this.modules.get(criteria.id);
      return module ? [module] : [];
    }

    if (criteria.type) {
      console.log(`[DEBUG] Searching for type: ${criteria.type}`);
      const typeIndexSet = this.typeIndex.get(criteria.type);
      console.log(
        `[DEBUG] Type index contains:`,
        typeIndexSet ? Array.from(typeIndexSet) : 'undefined'
      );
      console.log(
        `[DEBUG] Current candidateIds:`,
        candidateIds ? Array.from(candidateIds) : 'undefined'
      );
      candidateIds = this.intersectSets(candidateIds, typeIndexSet);
      indexBasedSearch = true;
      console.log(
        `[DEBUG] candidateIds after type intersection:`,
        candidateIds ? Array.from(candidateIds) : 'undefined'
      );
    }

    if (criteria.category) {
      candidateIds = this.intersectSets(
        candidateIds,
        this.categoryIndex.get(criteria.category)
      );
      indexBasedSearch = true;
    }

    if (criteria.tags) {
      if (criteria.tags.all && criteria.tags.all.length > 0) {
        // AND operation - module must have all specified tags
        for (const tag of criteria.tags.all) {
          candidateIds = this.intersectSets(
            candidateIds,
            this.tagIndex.get(tag)
          );
          if (!candidateIds || candidateIds.size === 0) break;
        }
        indexBasedSearch = true;
      }

      if (criteria.tags.any && criteria.tags.any.length > 0) {
        // OR operation - module must have at least one of the specified tags
        const tagUnion = new Set<string>();
        for (const tag of criteria.tags.any) {
          const taggedModules = this.tagIndex.get(tag);
          if (taggedModules) {
            taggedModules.forEach(id => tagUnion.add(id));
          }
        }
        candidateIds = this.intersectSets(candidateIds, tagUnion);
        indexBasedSearch = true;
      }
    }

    if (criteria.dependencies && criteria.dependencies.length > 0) {
      for (const dep of criteria.dependencies) {
        candidateIds = this.intersectSets(
          candidateIds,
          this.dependencyIndex.get(dep)
        );
        if (!candidateIds || candidateIds.size === 0) break;
      }
      indexBasedSearch = true;
    }

    if (criteria.conflicts && criteria.conflicts.length > 0) {
      for (const conflict of criteria.conflicts) {
        candidateIds = this.intersectSets(
          candidateIds,
          this.conflictIndex.get(conflict)
        );
        if (!candidateIds || candidateIds.size === 0) break;
      }
      indexBasedSearch = true;
    }

    // If index-based search was performed but no candidates found, return empty
    if (indexBasedSearch && !candidateIds) {
      return [];
    }

    // If no index-based filtering was applied, search all modules
    if (!candidateIds) {
      candidateIds = new Set(this.modules.keys());
    }

    // Apply remaining filters that require full module inspection
    const results: ModuleSchema[] = [];
    for (const id of Array.from(candidateIds)) {
      const module = this.modules.get(id);
      if (!module) continue;

      if (
        criteria.name &&
        !module.name.toLowerCase().includes(criteria.name.toLowerCase())
      ) {
        continue;
      }

      if (
        criteria.description &&
        !module.metadata.description
          .toLowerCase()
          .includes(criteria.description.toLowerCase())
      ) {
        continue;
      }

      if (
        criteria.author &&
        !module.metadata.author
          .toLowerCase()
          .includes(criteria.author.toLowerCase())
      ) {
        continue;
      }

      if (
        criteria.version &&
        !this.matchesVersionPattern(module.version, criteria.version)
      ) {
        continue;
      }

      results.push(module);
    }

    return results;
  }

  /**
   * Gets all registered modules
   * @returns Array of all modules in the registry
   */
  getAllModules(): ModuleSchema[] {
    return Array.from(this.modules.values());
  }

  /**
   * Removes a module from the registry
   * @param id Module ID to remove
   * @returns true if module was removed, false if not found
   */
  removeModule(id: string): boolean {
    const module = this.modules.get(id);
    if (!module) {
      return false;
    }

    // Remove from main storage
    this.modules.delete(id);

    // Remove from all indexes
    this.removeFromIndexes(module);

    console.log(`Module '${id}' removed from registry`);
    return true;
  }

  /**
   * Clears all modules from the registry
   */
  clear(): void {
    this.modules.clear();
    this.typeIndex.clear();
    this.categoryIndex.clear();
    this.tagIndex.clear();
    this.dependencyIndex.clear();
    this.conflictIndex.clear();
    console.log('Registry cleared of all modules');
  }

  /**
   * Loads modules from a directory using the ModuleLoader
   * @param directoryPath Path to directory containing modules
   * @throws ModuleDiscoveryError if directory discovery fails
   * @throws ModuleLoadError if module loading fails
   * @throws ModuleRegistrationError if module registration fails
   */
  async loadFromDirectory(directoryPath: string): Promise<void> {
    try {
      // Create a new ModuleLoader for this specific directory
      const loader = new ModuleLoader({ baseDir: directoryPath });

      // Discover module files
      const moduleFiles = await loader.discoverModules();
      console.log(
        `Discovered ${moduleFiles.length} module files in ${directoryPath}`
      );

      const loadResults = {
        successful: 0,
        failed: 0,
        errors: [] as string[],
      };

      // Load and register each module
      for (const filePath of moduleFiles) {
        try {
          const loadedModule = await loader.loadModule(filePath);

          // Extract the module schema from the loaded module
          const moduleSchema = this.extractModuleSchema(loadedModule);

          // Register the module
          this.registerModule(moduleSchema);
          loadResults.successful++;
        } catch (error) {
          loadResults.failed++;
          const errorMsg = `Failed to load module from ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`;
          loadResults.errors.push(errorMsg);
          console.error(errorMsg);
        }
      }

      console.log(
        `Module loading completed: ${loadResults.successful} successful, ${loadResults.failed} failed`
      );

      if (loadResults.errors.length > 0) {
        console.warn('Some modules failed to load:', loadResults.errors);
      }
    } catch (error) {
      if (error instanceof ModuleDiscoveryError) {
        throw error;
      }
      throw new ModuleDiscoveryError(
        directoryPath,
        error instanceof Error ? error : new Error(String(error))
      );
    }
  }

  /**
   * Saves the registry to a JSON file
   * @param filePath Path where to save the registry
   * @throws ModuleRegistryIOError if save operation fails
   */
  async saveRegistry(filePath: string): Promise<void> {
    try {
      const registryData = {
        version: '1.0.0',
        timestamp: new Date().toISOString(),
        modules: Array.from(this.modules.values()),
      };

      const jsonData = JSON.stringify(registryData, null, 2);

      // Ensure directory exists
      const dir = path.dirname(filePath);
      await fs.mkdir(dir, { recursive: true });

      await fs.writeFile(filePath, jsonData, 'utf-8');
      console.log(
        `Registry saved to ${filePath} with ${this.modules.size} modules`
      );
    } catch (error) {
      throw new ModuleRegistryIOError(
        filePath,
        'save',
        error instanceof Error ? error : new Error(String(error))
      );
    }
  }

  /**
   * Loads the registry from a JSON file
   * @param filePath Path to the registry file
   * @throws ModuleRegistryIOError if load operation fails
   * @throws ModuleRegistrationError if loaded modules are invalid
   */
  async loadRegistry(filePath: string): Promise<void> {
    try {
      const jsonData = await fs.readFile(filePath, 'utf-8');
      const registryData = JSON.parse(jsonData);

      if (!registryData.modules || !Array.isArray(registryData.modules)) {
        throw new Error(
          'Invalid registry file format: missing or invalid modules array'
        );
      }

      // Clear existing registry
      this.clear();

      let loadCount = 0;
      const errors: string[] = [];

      // Load each module
      for (const moduleData of registryData.modules) {
        try {
          this.registerModule(moduleData as ModuleSchema);
          loadCount++;
        } catch (error) {
          const errorMsg = `Failed to register module ${moduleData.id || 'unknown'}: ${error instanceof Error ? error.message : 'Unknown error'}`;
          errors.push(errorMsg);
        }
      }

      console.log(
        `Registry loaded from ${filePath}: ${loadCount} modules registered`
      );

      if (errors.length > 0) {
        console.warn(`${errors.length} modules failed to load:`, errors);
      }
    } catch (error) {
      throw new ModuleRegistryIOError(
        filePath,
        'load',
        error instanceof Error ? error : new Error(String(error))
      );
    }
  }

  /**
   * Gets registry statistics
   * @returns Object containing registry statistics
   */
  getStatistics(): {
    totalModules: number;
    modulesByType: Record<string, number>;
    modulesByCategory: Record<string, number>;
    topTags: Array<{ tag: string; count: number }>;
  } {
    const stats = {
      totalModules: this.modules.size,
      modulesByType: {} as Record<string, number>,
      modulesByCategory: {} as Record<string, number>,
      topTags: [] as Array<{ tag: string; count: number }>,
    };

    // Count by type
    for (const [type, moduleIds] of Array.from(this.typeIndex)) {
      stats.modulesByType[type] = moduleIds.size;
    }

    // Count by category
    for (const [category, moduleIds] of Array.from(this.categoryIndex)) {
      stats.modulesByCategory[category] = moduleIds.size;
    }

    // Top tags by usage
    const tagCounts = Array.from(this.tagIndex.entries())
      .map(([tag, moduleIds]) => ({ tag, count: moduleIds.size }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    stats.topTags = tagCounts;

    return stats;
  }

  /**
   * Adds a module to all relevant indexes
   * @param module Module to add to indexes
   */
  private addToIndexes(module: ModuleSchema): void {
    const id = module.id;

    // Type index
    console.log(
      `[DEBUG] Adding module ${id} to type index for type: ${module.type}`
    );
    if (!this.typeIndex.has(module.type)) {
      this.typeIndex.set(module.type, new Set());
      console.log(`[DEBUG] Created new set for type: ${module.type}`);
    }
    this.typeIndex.get(module.type)!.add(id);
    console.log(
      `[DEBUG] Type index for ${module.type} now contains:`,
      Array.from(this.typeIndex.get(module.type)!)
    );

    // Category index
    if (!this.categoryIndex.has(module.metadata.category)) {
      this.categoryIndex.set(module.metadata.category, new Set());
    }
    this.categoryIndex.get(module.metadata.category)!.add(id);

    // Tag index
    if (module.tags) {
      for (const tag of module.tags) {
        if (!this.tagIndex.has(tag)) {
          this.tagIndex.set(tag, new Set());
        }
        this.tagIndex.get(tag)!.add(id);
      }
    }

    // Dependency index
    if (module.dependencies) {
      for (const dep of module.dependencies) {
        if (!this.dependencyIndex.has(dep)) {
          this.dependencyIndex.set(dep, new Set());
        }
        this.dependencyIndex.get(dep)!.add(id);
      }
    }

    // Conflict index
    if (module.conflicts) {
      for (const conflict of module.conflicts) {
        if (!this.conflictIndex.has(conflict)) {
          this.conflictIndex.set(conflict, new Set());
        }
        this.conflictIndex.get(conflict)!.add(id);
      }
    }
  }

  /**
   * Removes a module from all relevant indexes
   * @param module Module to remove from indexes
   */
  private removeFromIndexes(module: ModuleSchema): void {
    const id = module.id;

    // Type index
    console.log(
      `[DEBUG] Removing module ${id} from type index for type: ${module.type}`
    );
    console.log(
      `[DEBUG] Type index before removal:`,
      Array.from(this.typeIndex.get(module.type) || [])
    );
    this.typeIndex.get(module.type)?.delete(id);
    if (this.typeIndex.get(module.type)?.size === 0) {
      console.log(
        `[DEBUG] Type ${module.type} index is now empty, removing entry`
      );
      this.typeIndex.delete(module.type);
    } else {
      console.log(
        `[DEBUG] Type index for ${module.type} after removal:`,
        Array.from(this.typeIndex.get(module.type) || [])
      );
    }

    // Category index
    this.categoryIndex.get(module.metadata.category)?.delete(id);
    if (this.categoryIndex.get(module.metadata.category)?.size === 0) {
      this.categoryIndex.delete(module.metadata.category);
    }

    // Tag index
    if (module.tags) {
      for (const tag of module.tags) {
        this.tagIndex.get(tag)?.delete(id);
        if (this.tagIndex.get(tag)?.size === 0) {
          this.tagIndex.delete(tag);
        }
      }
    }

    // Dependency index
    if (module.dependencies) {
      for (const dep of module.dependencies) {
        this.dependencyIndex.get(dep)?.delete(id);
        if (this.dependencyIndex.get(dep)?.size === 0) {
          this.dependencyIndex.delete(dep);
        }
      }
    }

    // Conflict index
    if (module.conflicts) {
      for (const conflict of module.conflicts) {
        this.conflictIndex.get(conflict)?.delete(id);
        if (this.conflictIndex.get(conflict)?.size === 0) {
          this.conflictIndex.delete(conflict);
        }
      }
    }
  }

  /**
   * Intersects two sets, handling undefined cases
   * @param setA First set (may be undefined)
   * @param setB Second set (may be undefined)
   * @returns Intersection of the sets, or undefined if either is undefined
   */
  private intersectSets(
    setA: Set<string> | undefined,
    setB: Set<string> | undefined
  ): Set<string> | undefined {
    if (!setA) return setB;
    if (!setB) return undefined;

    const result = new Set<string>();
    for (const item of Array.from(setA)) {
      if (setB.has(item)) {
        result.add(item);
      }
    }
    return result;
  }

  /**
   * Checks if a version matches a pattern (supports wildcards)
   * @param version Version to check
   * @param pattern Pattern to match (supports * wildcards)
   * @returns true if version matches pattern
   */
  private matchesVersionPattern(version: string, pattern: string): boolean {
    if (pattern === version) return true;

    // Convert pattern to regex (simple wildcard support)
    const regexPattern = pattern.replace(/\./g, '\\.').replace(/\*/g, '.*');

    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(version);
  }

  /**
   * Extracts ModuleSchema from a loaded module object
   * @param loadedModule Module object loaded by ModuleLoader
   * @returns ModuleSchema extracted from the module
   * @throws Error if module doesn't contain valid schema
   */
  private extractModuleSchema(loadedModule: unknown): ModuleSchema {
    // Type guard to check if loadedModule is an object
    if (typeof loadedModule !== 'object' || loadedModule === null) {
      throw new Error(
        'Unable to extract ModuleSchema from loaded module - module is not an object'
      );
    }

    const moduleObj = loadedModule as Record<string, unknown>;

    // Check for module schema in common export patterns
    if (
      moduleObj['default'] &&
      typeof moduleObj['default'] === 'object' &&
      moduleObj['default'] !== null
    ) {
      return moduleObj['default'] as ModuleSchema;
    }

    if (
      moduleObj['module'] &&
      typeof moduleObj['module'] === 'object' &&
      moduleObj['module'] !== null
    ) {
      return moduleObj['module'] as ModuleSchema;
    }

    // If the loaded module itself looks like a schema
    if (moduleObj['id'] && moduleObj['name'] && moduleObj['type']) {
      return loadedModule as ModuleSchema;
    }

    throw new Error(
      'Unable to extract ModuleSchema from loaded module - no valid schema found in exports'
    );
  }
}
